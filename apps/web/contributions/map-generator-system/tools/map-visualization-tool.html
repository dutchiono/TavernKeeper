<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>InnKeeper - Map Generator Visualization Tool</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #1a1a2e;
            color: #eee;
            height: 100vh;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
            min-height: 0;
        }

        /* Left Sidebar - Parameters */
        .left-sidebar {
            width: 280px;
            background: #16213e;
            border-right: 2px solid #0f3460;
            padding: 15px;
            overflow-y: auto;
            flex-shrink: 0;
        }

        .left-sidebar h2 {
            color: #ffd700;
            margin-bottom: 15px;
            font-size: 1.2em;
            text-align: center;
        }

        .control-group {
            margin-bottom: 15px;
            padding: 10px;
            background: #0f3460;
            border-radius: 4px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            color: #ffd700;
            font-weight: bold;
            font-size: 0.9em;
        }

        input[type="text"],
        input[type="number"],
        select {
            width: 100%;
            padding: 6px 10px;
            background: #1a1a2e;
            border: 2px solid #0f3460;
            color: #eee;
            font-family: 'Courier New', monospace;
            border-radius: 4px;
            font-size: 0.9em;
        }

        input[type="text"]:focus,
        input[type="number"]:focus,
        select:focus {
            outline: none;
            border-color: #ffd700;
        }

        input[type="range"] {
            width: 100%;
            cursor: pointer;
        }

        .slider-value {
            display: inline-block;
            min-width: 40px;
            text-align: right;
            color: #ffd700;
            font-weight: bold;
        }

        button {
            width: 100%;
            padding: 10px;
            background: #0f3460;
            border: 2px solid #ffd700;
            color: #ffd700;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.2s;
        }

        button:hover {
            background: #ffd700;
            color: #1a1a2e;
        }

        button:active {
            transform: scale(0.98);
        }

        /* Main View - Map Grid */
        .main-view {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #0f1419;
            overflow: hidden;
        }

        .map-header {
            padding: 10px 20px;
            background: #16213e;
            border-bottom: 2px solid #0f3460;
            color: #ffd700;
            font-size: 0.9em;
        }

        .map-container {
            flex: 1;
            overflow: auto;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
        }

        .map-grid {
            display: grid;
            gap: 2px;
            background: #0a0e14;
            padding: 10px;
            border: 2px solid #0f3460;
        }

        .map-cell {
            width: 24px;
            height: 24px;
            background: #1a2332;
            border: 1px solid #2a3441;
            cursor: pointer;
            transition: all 0.1s;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
        }

        .map-cell:hover {
            border-color: #ffd700;
            transform: scale(1.2);
            z-index: 10;
        }

        .map-cell.selected {
            border: 2px solid #ffd700;
            box-shadow: 0 0 8px #ffd700;
        }

        /* Cell types - most are empty */
        .map-cell.empty {
            background: #1a2332;
        }

        .map-cell.has-geography {
            background: #2d5016;
        }

        .map-cell.has-organization {
            background: #4a2c5a;
        }

        .map-cell.has-dungeon {
            background: #5a1a1a;
        }

        .map-cell.has-landmark {
            background: #3d3d1a;
        }

        .map-cell.has-ruin {
            background: #2a2a1a;
        }

        .map-cell.has-trading {
            background: #2a3a2a;
        }

        /* Right Sidebar - Cell Details */
        .right-sidebar {
            width: 450px;
            background: #16213e;
            border-left: 2px solid #0f3460;
            padding: 15px;
            overflow-y: auto;
            flex-shrink: 0;
        }

        .right-sidebar h2 {
            color: #ffd700;
            margin-bottom: 15px;
            font-size: 1.2em;
            text-align: center;
        }

        .cell-info {
            background: #0f3460;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 15px;
        }

        .cell-info h3 {
            color: #ffd700;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .cell-info p {
            margin-bottom: 8px;
            color: #ccc;
            font-size: 0.9em;
        }

        .cell-info .label {
            color: #ffd700;
            font-weight: bold;
        }

        .features-list {
            margin-top: 15px;
        }

        .feature-item {
            background: #1a1a2e;
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 4px;
            border-left: 3px solid #ffd700;
        }

        .feature-item h4 {
            color: #ffd700;
            margin-bottom: 5px;
            font-size: 1em;
        }

        .feature-item p {
            color: #aaa;
            font-size: 0.85em;
            margin-bottom: 8px;
            line-height: 1.5;
        }

        .feature-item strong {
            color: #ffd700;
        }

        .feature-item em {
            color: #ccc;
            font-style: italic;
        }

        .feature-type {
            display: inline-block;
            padding: 2px 6px;
            background: #0f3460;
            border-radius: 3px;
            font-size: 0.75em;
            color: #ffd700;
            margin-top: 10px;
        }

        .no-selection {
            text-align: center;
            color: #666;
            padding: 40px 20px;
            font-style: italic;
        }

        .legend {
            margin-top: 20px;
            padding: 10px;
            background: #0f3460;
            border-radius: 4px;
        }

        .legend h3 {
            color: #ffd700;
            font-size: 0.9em;
            margin-bottom: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 6px;
            font-size: 0.8em;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            margin-right: 8px;
            border: 1px solid #2a3441;
        }

        /* World History Section */
        .world-history {
            background: #16213e;
            border-top: 2px solid #0f3460;
            padding: 20px;
            max-height: 400px;
            overflow-y: auto;
            margin-top: 20px;
        }

        .world-history h3 {
            color: #ffd700;
            margin-bottom: 15px;
            font-size: 1.1em;
            text-align: center;
        }

        .history-entry {
            background: #0f3460;
            padding: 12px;
            margin-bottom: 10px;
            border-radius: 4px;
            border-left: 3px solid #ffd700;
        }

        .history-entry.critical {
            border-left-color: #ff4444;
        }

        .history-entry.important {
            border-left-color: #ffaa00;
        }

        .history-entry.normal {
            border-left-color: #ffd700;
        }

        .history-entry.verbose {
            border-left-color: #888;
        }

        .history-timestamp {
            color: #aaa;
            font-size: 0.8em;
            margin-bottom: 5px;
        }

        .history-summary {
            color: #eee;
            font-size: 0.9em;
            line-height: 1.5;
        }

        .history-meta {
            color: #888;
            font-size: 0.75em;
            margin-top: 5px;
        }
        
        .entity-link {
            color: #4da6ff;
            text-decoration: underline;
            cursor: pointer;
            font-weight: bold;
        }
        
        .entity-link:hover {
            color: #66b3ff;
        }
        
        /* Entity History Modal */
        .entity-history-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .entity-history-content {
            background: #16213e;
            border: 2px solid #0f3460;
            border-radius: 8px;
            width: 80%;
            max-width: 800px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }
        
        .entity-history-header {
            padding: 20px;
            border-bottom: 2px solid #0f3460;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .entity-history-header h2 {
            color: #ffd700;
            margin: 0;
        }
        
        .close-modal {
            background: #0f3460;
            border: 2px solid #ffd700;
            color: #ffd700;
            width: 30px;
            height: 30px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 20px;
            line-height: 1;
            padding: 0;
        }
        
        .close-modal:hover {
            background: #ffd700;
            color: #0f3460;
        }
        
        .entity-history-body {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
        }
    </style>
</head>
<body>
    <!-- Main Content Container -->
    <div class="main-content">
    <!-- Left Sidebar - Parameters -->
    <div class="left-sidebar">
        <h2>Map Parameters</h2>
        
        <div class="control-group">
            <label>World Seed</label>
            <input type="text" id="seed" value="my-world-seed" />
        </div>

        <div class="control-group">
            <label>Grid Size: <span class="slider-value" id="gridSizeValue">20</span></label>
            <input type="range" id="gridSize" min="10" max="50" value="20" />
        </div>

        <div class="control-group">
            <label>Feature Density</label>
            <select id="density">
                <option value="sparse">Sparse</option>
                <option value="normal" selected>Normal</option>
                <option value="dense">Dense</option>
            </select>
        </div>

        <div class="control-group">
            <label>Center X: <span class="slider-value" id="centerXValue">0</span></label>
            <input type="range" id="centerX" min="-50" max="50" value="0" />
        </div>

        <div class="control-group">
            <label>Center Y: <span class="slider-value" id="centerYValue">0</span></label>
            <input type="range" id="centerY" min="-50" max="50" value="0" />
        </div>

        <div class="control-group">
            <label>
                <input type="checkbox" id="includeDungeons" checked />
                Include Dungeons
            </label>
        </div>

        <button id="generateBtn">Generate Map</button>
        <button id="randomSeedBtn" style="margin-top: 10px;">Random Seed</button>
    </div>

    <!-- Main View - Map Grid -->
    <div class="main-view">
        <div class="map-header">
            <span>Map Visualization - Click cells to view details</span>
        </div>
        <div class="map-container">
            <div class="map-grid" id="mapGrid"></div>
        </div>
    </div>

    <!-- Right Sidebar - Cell Details -->
    <div class="right-sidebar">
        <h2>Cell Details</h2>
        <div id="cellDetails">
            <div class="no-selection">Select a cell to view details</div>
        </div>
        
        <div class="legend">
            <h3>Legend</h3>
            <div class="legend-item">
                <div class="legend-color empty"></div>
                <span>Empty (no marker)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color has-geography"></div>
                <span>Geography (G)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color has-organization"></div>
                <span>Organization (O)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color has-dungeon"></div>
                <span>Dungeon (D)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color has-landmark"></div>
                <span>Landmark (L)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color has-ruin"></div>
                <span>Ruin (R)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color has-trading"></div>
                <span>Trading Post (T)</span>
            </div>
        </div>
    </div>
    </div>

    <!-- World History Section -->
    <div class="world-history" id="worldHistory">
        <h3>World History</h3>
        <div id="historyEntries">
            <p style="text-align: center; color: #666; font-style: italic;">World history will appear here as events occur...</p>
        </div>
    </div>

    <script>
        // Map Generator Code (simplified for browser)
        class SeededRNG {
            constructor(seed) {
                if (typeof seed === 'string') {
                    this.seed = this.hashString(seed);
                } else {
                    this.seed = seed || Math.floor(Math.random() * 0xFFFFFFFF);
                }
            }

            hashString(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash;
                }
                return Math.abs(hash);
            }

            next() {
                let t = this.seed += 0x6D2B79F5;
                t = Math.imul(t ^ t >>> 15, t | 1);
                t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            }

            random() {
                return this.next();
            }
        }

        class SurfaceGenerator {
            generateCell(context, density = 'normal') {
                const { seed, x, y } = context;
                const features = [];

                const densityMultiplier = {
                    sparse: 0.3,
                    normal: 0.7,
                    dense: 1.2,
                }[density];

                // Generate features
                const additionalFeatures = this.generateAdditionalFeatures(context, densityMultiplier);
                features.push(...additionalFeatures);

                return {
                    id: `cell-${x}-${y}`,
                    x,
                    y,
                    seed,
                    features,
                    dungeonEntrances: [],
                    discoveredAt: new Date(),
                    metadata: { density },
                };
            }

            generateAdditionalFeatures(context, densityMultiplier) {
                const features = [];
                const rng = this.createRNG(`${context.seed}-additional`);

                // Geography (10% base chance * multiplier)
                if (rng() < 0.1 * densityMultiplier) {
                    const geoTypes = [
                        { type: 'forest', name: 'Ancient Forest' },
                        { type: 'mountain', name: 'Mountain Range' },
                        { type: 'river', name: 'Flowing River' },
                        { type: 'plains', name: 'Vast Plains' },
                        { type: 'desert', name: 'Barren Desert' },
                    ];
                    const selected = geoTypes[Math.floor(rng() * geoTypes.length)];
                    features.push({
                        id: `feature-geo-${context.x}-${context.y}`,
                        type: 'geography',
                        name: selected.name,
                        description: `A ${selected.type} feature in this area`,
                        source: 'geography',
                        metadata: { geographyType: selected.type },
                    });
                }

                // Organizations (5% base chance * multiplier)
                if (rng() < 0.05 * densityMultiplier) {
                    const orgTypes = [
                        { type: 'kingdom', name: 'Kingdom Settlement' },
                        { type: 'tower', name: 'Necromancer Tower' },
                        { type: 'horde', name: 'Orc Horde Camp' },
                        { type: 'town', name: 'Small Town' },
                        { type: 'graveyard', name: 'Ancient Graveyard' },
                    ];
                    const selected = orgTypes[Math.floor(rng() * orgTypes.length)];
                    features.push({
                        id: `feature-org-${context.x}-${context.y}`,
                        type: 'organization',
                        name: selected.name,
                        description: `A ${selected.type} located here`,
                        source: 'organization',
                        metadata: { organizationType: selected.type },
                    });
                }

                // Landmarks (3% base chance * multiplier)
                if (rng() < 0.03 * densityMultiplier) {
                    features.push({
                        id: `feature-landmark-${context.x}-${context.y}`,
                        type: 'landmark',
                        name: 'Ancient Landmark',
                        description: 'A mysterious landmark of unknown origin',
                        source: 'landmark',
                        metadata: {},
                    });
                }

                // Ruins (5% base chance * multiplier)
                if (rng() < 0.05 * densityMultiplier) {
                    features.push({
                        id: `feature-ruin-${context.x}-${context.y}`,
                        type: 'ruin',
                        name: 'Abandoned Ruins',
                        description: 'The remains of an ancient structure',
                        source: 'generated',
                        metadata: {},
                    });
                }

                // Trading posts (2% base chance * multiplier)
                if (rng() < 0.02 * densityMultiplier) {
                    features.push({
                        id: `feature-trading-${context.x}-${context.y}`,
                        type: 'trading_post',
                        name: 'Trading Post',
                        description: 'A small trading outpost',
                        source: 'generated',
                        metadata: {},
                    });
                }

                return features;
            }

            createRNG(seed) {
                const rng = new SeededRNG(seed);
                return () => rng.random();
            }
        }

        // Rich Content Generator
        class RichContentGenerator {
            createRNG(seed) {
                let hash = this.hashString(seed);
                return () => {
                    hash = ((hash * 9301) + 49297) % 233280;
                    return hash / 233280;
                };
            }

            generateFeatureContent(feature, cellSeed) {
                const rng = this.createRNG(`${cellSeed}-rich-${feature.id}`);
                const geoType = feature.metadata?.geographyType;
                const orgType = feature.metadata?.organizationType;

                let history = '';
                let story = '';
                let significance = '';
                let creator;
                let createdBy;
                let age;
                const inhabitants = [];
                const events = [];

                if (feature.type === 'geography') {
                    const ages = [50, 100, 200, 500, 1000, 2000];
                    age = ages[Math.floor(rng() * ages.length)];
                    
                    // Assign creator based on geography type
                    const creatorMap = {
                        forest: ['The Life Giver', 'The Wind Rider'],
                        plains: ['The Life Giver', 'The Earth Mover'],
                        mountain: ['The Stone Shaper', 'The Earth Mover'],
                        river: ['The Deep One', 'The Wind Rider'],
                        desert: ['The Flame Bearer', 'The Earth Mover'],
                    };
                    
                    const possibleCreators = creatorMap[geoType] || ['The Life Giver', 'The Earth Mover'];
                    creator = possibleCreators[Math.floor(rng() * possibleCreators.length)];
                    createdBy = creator;

                    const geoStories = {
                        forest: [
                            `This ancient forest was shaped by ${creator} ${age} years ago. The trees here are older than most civilizations, their roots reaching deep into the earth.`,
                            `Formed in an age long past, this forest has witnessed countless seasons. ${creator} planted the first seeds here, and the forest has grown wild and untamed ever since.`,
                        ],
                        plains: [
                            `These vast plains were created by ${creator} ${age} years ago. The endless grasslands stretch to the horizon, home to nomadic tribes and wild beasts.`,
                            `Once a barren wasteland, ${creator} blessed this land ${age} years ago, creating fertile plains that have supported life for generations.`,
                        ],
                        mountain: [
                            `These mountains were raised by ${creator} ${age} years ago in a great upheaval. The peaks pierce the clouds, their stone faces weathered by time.`,
                            `Forged by ${creator} ${age} years ago, these mountains have stood as silent guardians over the land, their secrets buried deep within.`,
                        ],
                        river: [
                            `This river was carved by ${creator} ${age} years ago, flowing from distant mountains to the sea. Its waters have sustained countless settlements.`,
                            `Born from the tears of ${creator} ${age} years ago, this river has been a lifeline for the region, its course unchanged for millennia.`,
                        ],
                        desert: [
                            `This desert was formed by ${creator} ${age} years ago, a harsh landscape of sand and stone. Few can survive its unforgiving climate.`,
                            `Created by ${creator} ${age} years ago, this desert was once a fertile land. A great cataclysm turned it to sand, and it has remained barren ever since.`,
                        ],
                    };

                    const stories = geoStories[geoType] || geoStories.plains;
                    story = stories[Math.floor(rng() * stories.length)];

                    if (geoType === 'plains' && rng() < 0.3) {
                        const banditLeaders = ['Blackthorn the Ruthless', 'Grimjaw the Cutthroat', 'Shadowblade', 'Ironfist the Bandit King', 'Raven the Raider'];
                        const leader = banditLeaders[Math.floor(rng() * banditLeaders.length)];
                        inhabitants.push({
                            type: 'bandits',
                            name: `The ${leader.split(' ')[0]} Bandits`,
                            leader,
                            description: `A band of ruthless bandits led by ${leader} prowl these plains, preying on travelers and merchants. They are known for their cruelty and have evaded capture for years.`,
                        });
                    }

                    if (geoType === 'forest' && rng() < 0.2) {
                        inhabitants.push({
                            type: 'creatures',
                            name: 'Forest Guardians',
                            description: 'Mysterious creatures dwell in the depths of this forest, rarely seen but always watching. Some say they are the spirits of the trees themselves.',
                        });
                    }

                    significance = `This ${geoType} has been a significant landmark for ${age} years, shaping the lives of those who live nearby.`;

                    if (rng() < 0.4) {
                        const eventTypes = [
                            { type: 'battle', desc: 'A great battle was fought here', time: 'decades' },
                            { type: 'discovery', desc: 'Ancient ruins were discovered', time: 'years' },
                            { type: 'cataclysm', desc: 'A great storm reshaped the land', time: 'centuries' },
                        ];
                        const event = eventTypes[Math.floor(rng() * eventTypes.length)];
                        events.push({ type: event.type, description: event.desc, timeAgo: event.time });
                    }
                } else if (feature.type === 'organization') {
                    const ages = [10, 25, 50, 100, 200, 500];
                    age = ages[Math.floor(rng() * ages.length)];

                    const orgStories = {
                        kingdom: [
                            `This kingdom was founded ${age} years ago by a legendary warrior-king. It has grown from a small settlement to a powerful realm, its walls standing strong against all threats.`,
                            `Established ${age} years ago, this kingdom has weathered wars, plagues, and famines. Its people are resilient, their culture rich with tradition and honor.`,
                        ],
                        tower: [
                            `This necromancer tower was built ${age} years ago by a dark sorcerer seeking immortality. The tower pulses with dark magic, and few dare approach its shadowed walls.`,
                            `Raised ${age} years ago through forbidden rituals, this tower serves as a beacon of dark power. The necromancer who built it still dwells within, conducting terrible experiments.`,
                        ],
                        horde: [
                            `This orc horde has been camped here for ${age} years, growing in strength and numbers. They are led by a brutal war-chief who dreams of conquest.`,
                            `Established ${age} years ago after a great migration, this horde has become a feared force in the region. Their war drums echo across the plains, a warning to all who hear them.`,
                        ],
                        town: [
                            `This town was founded ${age} years ago by settlers seeking a new life. It has grown into a bustling community, its markets filled with traders from distant lands.`,
                            `Built ${age} years ago at a crossroads, this town has prospered through trade. Its people are hardworking and friendly, always welcoming to travelers.`,
                        ],
                        graveyard: [
                            `This ancient graveyard has existed for ${age} years, the final resting place of countless souls. Some say the dead do not rest peacefully here.`,
                            `Established ${age} years ago after a great plague, this graveyard holds the remains of thousands. Dark magic has tainted the ground, and the undead sometimes rise from their graves.`,
                        ],
                    };

                    const stories = orgStories[orgType] || orgStories.town;
                    story = stories[Math.floor(rng() * stories.length)];

                    // Generate unique organization name
                    const orgNamePrefixes = {
                        kingdom: ['Kingdom of', 'Realm of', 'Domain of', 'Empire of', 'Crown of'],
                        horde: ['The', 'Horde of', 'Clan of', 'Tribe of'],
                        tower: ['Tower of', 'Spire of', 'Citadel of', 'Fortress of'],
                        town: ['Town of', 'Village of', 'Settlement of', 'Hamlet of'],
                        graveyard: ['Graveyard of', 'Necropolis of', 'Crypts of'],
                    };
                    const orgNameSuffixes = {
                        kingdom: ['Ironhold', 'Goldcrest', 'Silvermoon', 'Dragonheart', 'Stonethrone', 'Crystalpeak', 'Shadowvale', 'Brightwood'],
                        horde: ['Blood', 'Skull', 'Iron', 'Bone', 'War', 'Death', 'Rage', 'Fury'],
                        tower: ['Darkness', 'Shadows', 'Sorrow', 'Despair', 'Torment', 'Malice', 'Doom', 'Ruin'],
                        town: ['Crossroads', 'Haven', 'Rest', 'Hope', 'Prosperity', 'Trade', 'Merchant', 'Bridge'],
                        graveyard: ['Sorrows', 'Tears', 'Rest', 'Peace', 'Silence', 'Shadows', 'The Dead', 'Remembrance'],
                    };
                    
                    const prefixes = orgNamePrefixes[orgType] || ['The'];
                    const suffixes = orgNameSuffixes[orgType] || ['Unknown'];
                    const orgName = `${prefixes[Math.floor(rng() * prefixes.length)]} ${suffixes[Math.floor(rng() * suffixes.length)]}`;
                    
                    if (orgType === 'kingdom' || orgType === 'horde' || orgType === 'tower') {
                        // Generate unique leader name
                        const firstNames = {
                            kingdom: ['Aethelred', 'Isolde', 'Valerius', 'Elena', 'Marcus', 'Sophia', 'Theodore', 'Victoria', 'Edmund', 'Arianna'],
                            horde: ['Grubnak', 'Bloodaxe', 'Skullcrusher', 'Grimjaw', 'Ironfist', 'Bonebreaker', 'Gorefang', 'Deathclaw'],
                            tower: ['Malachar', 'Vex', 'Zephyr', 'Necros', 'Mordred', 'Vexius', 'Malice', 'Doom'],
                        };
                        const titles = {
                            kingdom: ['King', 'Queen', 'Lord', 'Lady', 'Duke', 'Duchess'],
                            horde: ['War-Chief', 'Chieftain', 'Warlord', 'Battlemaster'],
                            tower: ['Necromancer', 'Lich Lord', 'Dark Mage', 'Archmage', 'Sorcerer'],
                        };
                        
                        const nameList = firstNames[orgType] || ['Unknown'];
                        const titleList = titles[orgType] || ['Leader'];
                        const firstName = nameList[Math.floor(rng() * nameList.length)];
                        const title = titleList[Math.floor(rng() * titleList.length)];
                        
                        // Add epithet
                        const epithets = ['the Bold', 'the Wise', 'the Great', 'the Conqueror', 'the Builder', 'the Mighty', 'the Fierce', 'the Ancient'];
                        const epithet = epithets[Math.floor(rng() * epithets.length)];
                        const leaderName = `${title} ${firstName} ${epithet}`;
                        const leaderEntityId = `mortal-${firstName}-${age}-${Math.floor(rng() * 1000)}`;
                        
                        inhabitants.push({
                            type: 'leader',
                            name: leaderName,
                            entityId: leaderEntityId,
                            description: `${leaderName} rules ${orgName} with ${orgType === 'tower' ? 'dark magic' : orgType === 'horde' ? 'brutal strength' : 'wisdom and justice'}.`,
                        });
                    }
                    
                    // Store organization name and entity ID for history tracking
                    feature.metadata = feature.metadata || {};
                    feature.metadata.organizationName = orgName;
                    feature.metadata.organizationEntityId = `org-${orgName}-${age}-${Math.floor(rng() * 1000)}`;

                    significance = `This ${orgType} has been a significant power in the region for ${age} years, influencing the lives of all who live nearby.`;
                } else if (feature.type === 'ruin') {
                    // Generate rich content for ruins
                    const ages = [100, 200, 500, 1000, 2000];
                    age = ages[Math.floor(rng() * ages.length)];
                    
                    const ruinBuilders = ['Ancient Dwarven Kingdom', 'Forgotten Empire', 'Lost Civilization', 'Ancient Elven Realm', 'Unknown Precursors'];
                    const builder = ruinBuilders[Math.floor(rng() * ruinBuilders.length)];
                    
                    const ruinStories = [
                        `These ruins were once part of ${builder}, abandoned ${age} years ago after a great catastrophe. The structures have crumbled with time, but their purpose remains a mystery.`,
                        `The remains of an ancient settlement built by ${builder} ${age} years ago. What caused its abandonment is lost to history, but the ruins tell a story of a once-great civilization.`,
                        `These abandoned ruins were constructed by ${builder} ${age} years ago. Nature has reclaimed much of the site, but the stone foundations still stand as a testament to those who came before.`,
                    ];
                    
                    story = ruinStories[Math.floor(rng() * ruinStories.length)];
                    creator = builder;
                    createdBy = builder;
                    significance = `These ruins have stood for ${age} years, a silent reminder of civilizations long past.`;
                    
                    // Add historical events for ruins
                    if (rng() < 0.5) {
                        events.push({
                            type: 'abandonment',
                            description: 'The settlement was abandoned',
                            timeAgo: 'centuries',
                        });
                    }
                } else if (feature.type === 'landmark') {
                    // Generate rich content for landmarks
                    const ages = [200, 500, 1000, 2000, 3000];
                    age = ages[Math.floor(rng() * ages.length)];
                    
                    const landmarkOrigins = [
                        'erected by ancient druids',
                        'carved by the first mortals',
                        'formed by cosmic forces',
                        'created by primordial beings',
                        'left by unknown travelers',
                    ];
                    const origin = landmarkOrigins[Math.floor(rng() * landmarkOrigins.length)];
                    
                    const landmarkStories = [
                        `This ancient landmark was ${origin} ${age} years ago. Its purpose and meaning have been lost to time, but it radiates an aura of ancient power.`,
                        `A mysterious landmark ${origin} ${age} years ago. Scholars debate its origin, but all agree it predates recorded history and holds great significance.`,
                        `This landmark stands as it has for ${age} years, ${origin}. Its strange geometry and unknown purpose have made it a place of pilgrimage and speculation.`,
                    ];
                    
                    story = landmarkStories[Math.floor(rng() * landmarkStories.length)];
                    creator = 'Ancient forces';
                    createdBy = 'Ancient forces';
                    significance = `This landmark has been a point of interest for ${age} years, drawing travelers and scholars from across the world.`;
                } else if (feature.type === 'trading_post') {
                    // Generate rich content for trading posts
                    const ages = [5, 10, 25, 50, 100];
                    age = ages[Math.floor(rng() * ages.length)];
                    
                    const tradingStories = [
                        `This trading post was established ${age} years ago at a strategic crossroads. It has become a hub of commerce, connecting distant settlements.`,
                        `Built ${age} years ago, this trading post serves as a vital link in the trade routes. Merchants from all corners of the world pass through here.`,
                    ];
                    
                    story = tradingStories[Math.floor(rng() * tradingStories.length)];
                    creator = 'Merchants';
                    createdBy = 'Merchants';
                    significance = `This trading post has facilitated commerce for ${age} years, bringing prosperity to the region.`;
                }

                return {
                    feature,
                    history: story,
                    provenance: { creator, createdBy, age, origin: undefined },
                    lore: { story, significance, connections: [] },
                    inhabitants: inhabitants.length > 0 ? inhabitants : undefined,
                    events: events.length > 0 ? events : undefined,
                };
            }

            generateDungeonContent(dungeonSeed, entranceX, entranceY) {
                const rng = this.createRNG(`${dungeonSeed}-rich`);
                const ages = [50, 100, 200, 500, 1000];
                const age = ages[Math.floor(rng() * ages.length)];
                const builders = ['Ancient Dwarven Kingdom', 'Dark Necromancer Cult', 'Forgotten Empire', 'Ancient Dragons', 'Lost Civilization'];
                const builder = builders[Math.floor(rng() * builders.length)];
                const purposes = ['mining operation', 'necromantic research', 'prison for dark creatures', 'treasure vault', 'ancient temple', 'underground fortress'];
                const purpose = purposes[Math.floor(rng() * purposes.length)];

                const dungeonName = this.generateDungeonName(dungeonSeed, rng);
                const maxDepth = 100;
                const history = `This dungeon was built ${age} years ago by the ${builder} as a ${purpose}. Over the centuries, it has been abandoned, conquered, and reclaimed by various forces. The deepest levels hold secrets that have been lost to time, and dark creatures now call it home.`;
                const story = `${dungeonName} stands as a testament to the ${builder}'s power. Built ${age} years ago, it was once a thriving ${purpose}, but now it is a place of danger and mystery. Those who venture within rarely return, and those who do speak of horrors beyond imagination.`;

                const mainBoss = this.generateBoss(maxDepth, dungeonSeed, 'main', rng);
                const midBosses = [];
                [25, 50, 75].forEach(level => {
                    if (level < maxDepth && rng() < 0.7) {
                        midBosses.push(this.generateBoss(level, dungeonSeed, 'mid', rng));
                    }
                });

                return {
                    dungeon: { name: dungeonName, maxDepth, entranceX, entranceY },
                    history,
                    provenance: { builder, builtBy: builder, age, purpose },
                    lore: { story, significance: `This dungeon is one of the most dangerous places in the region, its depths holding secrets from an age long past.` },
                    mainBoss,
                    midBosses: midBosses.length > 0 ? midBosses : undefined,
                };
            }

            generateBoss(level, seed, type, rng) {
                const bossSeed = `${seed}-boss-${level}-${type}`;
                const bossRNG = this.createRNG(bossSeed);
                const bossTypes = type === 'main' 
                    ? ['Lich', 'Ancient Dragon', 'Demon Lord', 'Vampire Lord', 'Dark Archmage']
                    : ['Orc Warlord', 'Troll Chieftain', 'Dark Knight', 'Necromancer', 'Giant Spider Queen'];
                const bossNames = {
                    'Lich': ['Malachar the Eternal', 'Vex the Undying', 'Zephyr the Deathless'],
                    'Ancient Dragon': ['Drakon the Ancient', 'Ignis the Flame-Breath', 'Frostfang the Eternal'],
                    'Demon Lord': ['Balrog the Destroyer', 'Mephisto the Corruptor', 'Azazel the Fallen'],
                    'Vampire Lord': ['Vlad the Immortal', 'Nosferatu the Ancient', 'Dracula the Blood-Drinker'],
                    'Dark Archmage': ['Malachar the Black', 'Vex the Shadow-Weaver', 'Zephyr the Dark'],
                    'Orc Warlord': ['Grubnak the Fierce', 'Bloodaxe the Savage', 'Skullcrusher the Brutal'],
                    'Troll Chieftain': ['Grok the Massive', 'Boulder the Unstoppable', 'Stonefist the Mighty'],
                    'Dark Knight': ['Blackthorn the Fallen', 'Shadowblade the Cursed', 'Ironfist the Damned'],
                    'Necromancer': ['Malachar the Dark', 'Vex the Death-Caller', 'Zephyr the Bone-Raiser'],
                    'Giant Spider Queen': ['Arachnia the Web-Weaver', 'Venomfang the Poisonous', 'Silkstrand the Trapper'],
                };
                const bossType = bossTypes[Math.floor(bossRNG() * bossTypes.length)];
                const nameList = bossNames[bossType] || [`${bossType} of Level ${level}`];
                const name = nameList[Math.floor(bossRNG() * nameList.length)];
                const powers = [];
                const powerCount = type === 'main' ? 3 : 2;
                const allPowers = ['Dark Magic', 'Necromancy', 'Fire Breath', 'Shadow Manipulation', 'Mind Control', 'Regeneration', 'Summoning', 'Curses'];
                for (let i = 0; i < powerCount; i++) {
                    const power = allPowers[Math.floor(bossRNG() * allPowers.length)];
                    if (!powers.includes(power)) powers.push(power);
                }
                const histories = {
                    'Lich': [
                        `Once a powerful archmage, ${name} sought immortality through dark magic. After centuries of undeath, they have become a master of necromancy, commanding legions of undead.`,
                        `${name} was a scholar who delved too deep into forbidden knowledge. They achieved lichdom ${Math.floor(bossRNG() * 500 + 100)} years ago and have been amassing power ever since.`,
                    ],
                    'Ancient Dragon': [
                        `${name} has slumbered in these depths for over a thousand years. This ancient wyrm is one of the last of its kind, its scales harder than steel and its breath capable of melting stone.`,
                        `A legendary dragon from the age of myth, ${name} was sealed away here long ago. The seal has weakened, and the dragon's power grows with each passing year.`,
                    ],
                };
                const historyList = histories[bossType] || [`${name} has ruled this level of the dungeon for many years, their power growing with each victim they claim.`];
                return {
                    name,
                    type: bossType,
                    level: -Math.abs(level),
                    description: `${name} is a ${bossType.toLowerCase()} of immense power, commanding this level with ${powers.join(' and ')}.`,
                    history: historyList[Math.floor(bossRNG() * historyList.length)],
                    powers,
                };
            }

            generateDungeonName(seed, rng) {
                const prefixes = ['Ancient', 'Forgotten', 'Dark', 'Cursed', 'Lost'];
                const suffixes = ['Caverns', 'Depths', 'Catacombs', 'Mines', 'Labyrinth'];
                return `${prefixes[Math.floor(rng() * prefixes.length)]} ${suffixes[Math.floor(rng() * suffixes.length)]}`;
            }

            hashString(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash;
                }
                return Math.abs(hash);
            }
        }

        // World History Generator (simulates game-logging-system)
        // Entity Registry (inline browser-compatible version)
        class EntityRegistry {
            constructor() {
                this.entities = new Map();
                this.creatorRelationships = new Map(); // creatorId -> Set<createdEntityIds>
                this.typeIndex = new Map(); // type -> Set<entityIds>
                this.raceIndex = new Map(); // race -> Set<entityIds>
            }

            registerEntity(entityId, data) {
                const entity = {
                    ...data,
                    entityId,
                    events: data.events || [],
                };

                this.entities.set(entityId, entity);

                // Index by type
                if (!this.typeIndex.has(data.type)) {
                    this.typeIndex.set(data.type, new Set());
                }
                this.typeIndex.get(data.type).add(entityId);

                // Index by race (if applicable)
                if (data.race) {
                    if (!this.raceIndex.has(data.race)) {
                        this.raceIndex.set(data.race, new Set());
                    }
                    this.raceIndex.get(data.race).add(entityId);
                }

                // Track creator relationships
                if (data.creatorId) {
                    if (!this.creatorRelationships.has(data.creatorId)) {
                        this.creatorRelationships.set(data.creatorId, new Set());
                    }
                    this.creatorRelationships.get(data.creatorId).add(entityId);
                }

                return entity;
            }

            getEntity(entityId) {
                return this.entities.get(entityId);
            }

            getEntitiesByType(type) {
                const entityIds = this.typeIndex.get(type) || new Set();
                return Array.from(entityIds)
                    .map(id => this.entities.get(id))
                    .filter(e => e !== undefined);
            }

            getEntitiesByRace(race) {
                const entityIds = this.raceIndex.get(race) || new Set();
                return Array.from(entityIds)
                    .map(id => this.entities.get(id))
                    .filter(e => e !== undefined);
            }

            addEventToEntity(entityId, event) {
                const entity = this.entities.get(entityId);
                if (entity) {
                    entity.events.push(event);
                    entity.events.sort((a, b) => a.year - b.year);
                }
            }

            getEntityHistory(entityId, minImportance = 'verbose') {
                const entity = this.entities.get(entityId);
                if (!entity) return [];

                const importanceLevels = { 'critical': 4, 'important': 3, 'normal': 2, 'verbose': 1 };
                const minLevel = importanceLevels[minImportance] || 1;

                return entity.events.filter(e => {
                    const level = importanceLevels[e.importance] || 2;
                    return level >= minLevel;
                });
            }

            getProvenanceChain(entityId) {
                const chain = [];
                let currentId = entityId;
                const visited = new Set();

                while (currentId && !visited.has(currentId)) {
                    visited.add(currentId);
                    const entity = this.entities.get(currentId);
                    if (!entity) break;

                    chain.push({
                        entityId: currentId,
                        name: entity.name,
                        type: entity.type,
                        relationship: currentId === entityId ? 'self' : 'created_by',
                    });

                    currentId = entity.creatorId || entity.originId;
                }

                return { entityId, chain };
            }

            getCreatedEntities(entityId) {
                const createdIds = this.creatorRelationships.get(entityId) || new Set();
                return Array.from(createdIds)
                    .map(id => this.entities.get(id))
                    .filter(e => e !== undefined);
            }

            getRelatedEntities(entityId) {
                const entity = this.entities.get(entityId);
                if (!entity) return [];

                const related = new Set();
                if (entity.creatorId) related.add(entity.creatorId);
                if (entity.originId) related.add(entity.originId);
                if (entity.location) related.add(entity.location);

                const created = this.getCreatedEntities(entityId);
                created.forEach(e => related.add(e.entityId));

                if (entity.race) {
                    const sameRace = this.getEntitiesByRace(entity.race);
                    sameRace.forEach(e => {
                        if (e.entityId !== entityId) related.add(e.entityId);
                    });
                }

                return Array.from(related)
                    .map(id => this.entities.get(id))
                    .filter(e => e !== undefined);
            }

            searchEntities(query) {
                const lowerQuery = query.toLowerCase();
                return Array.from(this.entities.values()).filter(
                    entity => entity.name.toLowerCase().includes(lowerQuery)
                );
            }

            getAllEntities() {
                return Array.from(this.entities.values());
            }
        }

        class WorldHistoryGenerator {
            constructor(seed) {
                this.events = [];
                this.seed = seed || 'default-seed';
                this.currentYear = 0; // Current in-world year (present day)
                this.worldStartYear = -5000; // World began 5000 years ago
                this.primordials = [];
                this.cosmicCreators = [];
                this.geography = [];
                this.organizations = [];
                this.dungeons = [];
                this.mortalRaces = [];
                
                // Universal Entity Registry
                this.entityRegistry = new EntityRegistry();
                // Legacy entities map for backward compatibility
                this.entities = this.entityRegistry.entities;
                
                // Initialize RNG (must be before generateWorldTimeline)
                this.rng = this.createRNG(this.seed);
                
                // Generate the full world timeline
                this.generateWorldTimeline();
            }
            
            /**
             * Register an entity in the universal registry
             */
            registerEntity(entityId, data) {
                return this.entityRegistry.registerEntity(entityId, data);
            }
            
            /**
             * Get entity from registry
             */
            getEntity(entityId) {
                return this.entityRegistry.getEntity(entityId);
            }
            
            /**
             * Get provenance chain for an entity
             */
            getProvenanceChain(entityId) {
                return this.entityRegistry.getProvenanceChain(entityId);
            }
            
            /**
             * Get entities created by this entity
             */
            getCreatedEntities(entityId) {
                return this.entityRegistry.getCreatedEntities(entityId);
            }
            
            /**
             * Get related entities
             */
            getRelatedEntities(entityId) {
                return this.entityRegistry.getRelatedEntities(entityId);
            }
            
            /**
             * Search entities by name
             */
            searchEntities(query) {
                return this.entityRegistry.searchEntities(query);
            }

            createRNG(seed) {
                let hash = this.hashString(seed);
                return () => {
                    hash = ((hash * 9301) + 49297) % 233280;
                    return hash / 233280;
                };
            }

            hashString(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash;
                }
                return Math.abs(hash);
            }

            logEvent(year, type, summary, importance = 'normal', metadata = {}) {
                const event = {
                    id: `event-${year}-${Date.now()}-${Math.random()}`,
                    type,
                    summary,
                    importance,
                    year,
                    metadata,
                };
                this.events.push(event);
                
                // Add event to all relevant entities in the registry
                const entityIds = new Set();
                
                // Primary entity
                if (metadata.entityId) {
                    entityIds.add(metadata.entityId);
                }
                
                // Related entities
                if (metadata.organizationId) entityIds.add(metadata.organizationId);
                if (metadata.founderId) entityIds.add(metadata.founderId);
                if (metadata.creatorId) entityIds.add(metadata.creatorId);
                if (metadata.originId) entityIds.add(metadata.originId);
                if (metadata.locationId) entityIds.add(metadata.locationId);
                if (metadata.race && metadata.raceEntityId) entityIds.add(metadata.raceEntityId);
                
                // Add event to each entity
                entityIds.forEach(entityId => {
                    this.entityRegistry.addEventToEntity(entityId, event);
                });
                
                return event;
            }
            
            // Get events filtered by importance (for main world history)
            getAllEvents(minImportance = 'normal') {
                const importanceLevels = { 'critical': 4, 'important': 3, 'normal': 2, 'verbose': 1 };
                const minLevel = importanceLevels[minImportance] || 2;
                
                return this.events
                    .filter(e => (importanceLevels[e.importance] || 2) >= minLevel)
                    .sort((a, b) => a.year - b.year);
            }
            
            // Get nested history for a specific entity
            getEntityHistory(entityId, minImportance = 'verbose') {
                return this.entityRegistry.getEntityHistory(entityId, minImportance);
            }
            
            // Get all entities of a specific type
            getEntitiesByType(type) {
                return this.entityRegistry.getEntitiesByType(type);
            }
            
            // Get all entities by race
            getEntitiesByRace(race) {
                return this.entityRegistry.getEntitiesByRace(race);
            }

            generateWorldTimeline() {
                // Level 1: Primordial Beings (Year -5000 to -4500)
                this.generatePrimordials();
                
                // Level 2: Cosmic Creators (Year -4500 to -4000)
                this.generateCosmicCreators();
                
                // Level 2.5: Geography (Year -4000 to -3000)
                this.generateGeography();
                
                // Level 5: Mortal Races (Year -3000 to -2600)
                this.generateMortalRaces();
                
                // Level 3: Conceptual Beings (Year -2500 to -2000) - Born from mortal worship AFTER races exist
                // Must come after all mortal races are created
                this.generateConceptualBeings();
                
                // Level 6: Organizations (Year -2500 to -1000)
                this.generateOrganizations();
            }

            generatePrimordials() {
                // Generate procedural primordial names based on seed
                const primordialTypes = [
                    { type: 'Space', year: -5000 },
                    { type: 'Time', year: -4950 },
                    { type: 'Light', year: -4900 },
                    { type: 'Dark', year: -4850 },
                    { type: 'Order', year: -4800 },
                    { type: 'Chaos', year: -4750 },
                ];

                const namePrefixes = ['The', 'The Great', 'The Eternal', 'The Infinite', 'The Boundless'];
                const nameSuffixes = {
                    'Space': ['Void', 'Abyss', 'Expanse', 'Nothingness'],
                    'Time': ['Eternal', 'Timeless', 'Chronos', 'Duration'],
                    'Light': ['Radiance', 'Brilliance', 'Luminance', 'Glow'],
                    'Dark': ['Shadow', 'Void', 'Darkness', 'Gloom'],
                    'Order': ['Order', 'Structure', 'Harmony', 'Balance'],
                    'Chaos': ['Chaos', 'Entropy', 'Disorder', 'Turmoil'],
                };

                primordialTypes.forEach((primordial, index) => {
                    const rng = this.createRNG(`${this.seed}-primordial-${index}`);
                    const prefix = namePrefixes[Math.floor(rng() * namePrefixes.length)];
                    const suffixes = nameSuffixes[primordial.type];
                    const suffix = suffixes[Math.floor(rng() * suffixes.length)];
                    const name = `${prefix} ${suffix}`;
                    const entityId = `primordial-${primordial.type}`;
                    
                    // Register entity
                    this.registerEntity(entityId, {
                        id: entityId,
                        name,
                        type: 'primordial',
                        entityId,
                        metadata: { primordialType: primordial.type },
                        createdAt: primordial.year,
                    });
                    
                    this.logEvent(
                        primordial.year,
                        'primordial',
                        `${name} (${primordial.type}) coalesced from the primordial chaos, becoming one of the fundamental forces that would shape all existence.`,
                        'critical',
                        { 
                            primordialType: primordial.type, 
                            name,
                            entityId,
                        }
                    );
                    this.primordials.push({ name, entityId, ...primordial });
                });
            }

            generateCosmicCreators() {
                // Generate procedural cosmic creator names and assign to primordials
                const elements = [
                    { element: 'Rock', year: -4500 },
                    { element: 'Wind', year: -4450 },
                    { element: 'Water', year: -4400 },
                    { element: 'Life', year: -4350 },
                    { element: 'Fire', year: -4300 },
                    { element: 'Earth', year: -4250 },
                ];

                const elementNames = {
                    'Rock': { prefixes: ['The Stone', 'The Rock', 'The Granite'], suffixes: ['Shaper', 'Carver', 'Mason', 'Sculptor'] },
                    'Wind': { prefixes: ['The Wind', 'The Breeze', 'The Gale'], suffixes: ['Rider', 'Whisperer', 'Caller', 'Dancer'] },
                    'Water': { prefixes: ['The Deep', 'The Flowing', 'The Tidal'], suffixes: ['One', 'Current', 'Waters', 'Ocean'] },
                    'Life': { prefixes: ['The Life', 'The Growth', 'The Blooming'], suffixes: ['Giver', 'Sower', 'Nurturer', 'Creator'] },
                    'Fire': { prefixes: ['The Flame', 'The Blaze', 'The Ember'], suffixes: ['Bearer', 'Kindler', 'Igniter', 'Forge'] },
                    'Earth': { prefixes: ['The Earth', 'The Ground', 'The Soil'], suffixes: ['Mover', 'Shaker', 'Tiller', 'Builder'] },
                };

                // Map elements to appropriate primordials
                const primordialAssignments = {
                    'Rock': ['Space', 'Order'],
                    'Wind': ['Time', 'Chaos'],
                    'Water': ['Light', 'Dark'],
                    'Life': ['Light', 'Order'],
                    'Fire': ['Chaos', 'Dark'],
                    'Earth': ['Space', 'Order'],
                };

                elements.forEach((elem, index) => {
                    const rng = this.createRNG(`${this.seed}-cosmic-${index}`);
                    const nameData = elementNames[elem.element];
                    const prefix = nameData.prefixes[Math.floor(rng() * nameData.prefixes.length)];
                    const suffix = nameData.suffixes[Math.floor(rng() * nameData.suffixes.length)];
                    const name = `${prefix} ${suffix}`;
                    
                    // Assign to appropriate primordial
                    const possiblePrimordials = primordialAssignments[elem.element];
                    const primordialType = possiblePrimordials[Math.floor(rng() * possiblePrimordials.length)];
                    const primordial = this.primordials.find(p => p.type === primordialType);
                    const createdBy = primordial ? primordial.name : `The ${primordialType}`;
                    const creatorEntityId = primordial ? primordial.entityId : `primordial-${primordialType}`;
                    const entityId = `cosmic-${elem.element}-${index}`;
                    
                    // Register entity
                    this.registerEntity(entityId, {
                        id: entityId,
                        name,
                        type: 'cosmic_creator',
                        entityId,
                        creatorId: creatorEntityId,
                        originId: creatorEntityId,
                        metadata: { element: elem.element, createdBy },
                        createdAt: elem.year,
                    });
                    
                    this.logEvent(
                        elem.year,
                        'cosmic_creator',
                        `${name}, an elemental being of ${elem.element}, was formed from the essence of ${createdBy}. ${name} began shaping the physical world, bringing ${elem.element} into existence.`,
                        'critical',
                        { 
                            element: elem.element, 
                            createdBy, 
                            name,
                            entityId,
                            creatorId: creatorEntityId,
                        }
                    );
                    this.cosmicCreators.push({ name, element: elem.element, createdBy, year: elem.year, entityId, creatorEntityId });
                });
            }

            generateGeography() {
                // Use actual cosmic creators from the generated list
                const stoneCreator = this.cosmicCreators.find(c => c.element === 'Rock')?.name || 'The Stone Shaper';
                const waterCreator = this.cosmicCreators.find(c => c.element === 'Water')?.name || 'The Deep One';
                const earthCreator = this.cosmicCreators.find(c => c.element === 'Earth')?.name || 'The Earth Mover';
                const lifeCreator = this.cosmicCreators.find(c => c.element === 'Life')?.name || 'The Life Giver';
                const fireCreator = this.cosmicCreators.find(c => c.element === 'Fire')?.name || 'The Flame Bearer';
                
                // Generate major geographical features over time
                const geoEvents = [
                    { name: 'The Northern Wastes', type: 'continent', creator: stoneCreator, year: -4000 },
                    { name: 'The Endless Sea', type: 'ocean', creator: waterCreator, year: -3900 },
                    { name: 'The Dragon\'s Spine Mountains', type: 'mountain_range', creator: earthCreator, year: -3800 },
                    { name: 'The Great River', type: 'river', creator: waterCreator, year: -3700 },
                    { name: 'The Whispering Forest', type: 'forest', creator: lifeCreator, year: -3600 },
                    { name: 'The Barren Desert', type: 'desert', creator: fireCreator, year: -3500 },
                ];

                geoEvents.forEach((geo, index) => {
                    const creatorEntity = this.cosmicCreators.find(c => c.name === geo.creator);
                    const creatorEntityId = creatorEntity ? creatorEntity.entityId : null;
                    const entityId = `geography-${geo.name.replace(/\s+/g, '-').toLowerCase()}`;
                    
                    // Register entity
                    this.registerEntity(entityId, {
                        id: entityId,
                        name: geo.name,
                        type: 'geography',
                        entityId,
                        creatorId: creatorEntityId,
                        originId: creatorEntityId,
                        metadata: { geographyType: geo.type, creator: geo.creator },
                        createdAt: geo.year,
                    });
                    
                    this.logEvent(
                        geo.year,
                        'geography',
                        `${geo.name}, a vast ${geo.type}, was formed by ${geo.creator} as ${geo.creator} shaped the physical world.`,
                        'important',
                        { 
                            geographyType: geo.type, 
                            creator: geo.creator, 
                            name: geo.name,
                            entityId,
                            creatorId: creatorEntityId,
                        }
                    );
                    this.geography.push({ ...geo, entityId, creatorEntityId });
                });
            }

            generateMortalRaces() {
                // Use actual cosmic creators from the generated list
                const lifeCreator = this.cosmicCreators.find(c => c.element === 'Life')?.name || 'The Life Giver';
                const stoneCreator = this.cosmicCreators.find(c => c.element === 'Rock')?.name || 'The Stone Shaper';
                const chaosPrimordial = this.primordials.find(p => p.type === 'Chaos')?.name || 'The Chaos';
                const darkPrimordial = this.primordials.find(p => p.type === 'Dark')?.name || 'The Shadow';
                
                const races = [
                    { name: 'Humans', creator: lifeCreator, homeland: 'The Northern Wastes', year: -3000 },
                    { name: 'Dwarves', creator: stoneCreator, homeland: 'The Dragon\'s Spine Mountains', year: -2900 },
                    { name: 'Elves', creator: lifeCreator, homeland: 'The Whispering Forest', year: -2800 },
                    { name: 'Orcs', creator: chaosPrimordial, homeland: 'The Barren Desert', year: -2700 },
                    { name: 'Goblins', creator: darkPrimordial, homeland: 'The Northern Wastes', year: -2600 },
                ];
                
                // Store races for use in conceptual being generation
                this.mortalRaces = races;

                races.forEach(race => {
                    const rng = this.createRNG(`${this.seed}-race-${race.name}`);
                    const creationMethods = [
                        `were given life by ${race.creator}`,
                        `were born from the essence of ${race.creator}`,
                        `emerged as ${race.creator} breathed life into the world`,
                        `were created when ${race.creator} shaped the first mortals`,
                    ];
                    const method = creationMethods[Math.floor(rng() * creationMethods.length)];
                    
                    const creatorEntity = this.cosmicCreators.find(c => c.name === race.creator) || 
                                        this.primordials.find(p => p.name === race.creator);
                    const creatorEntityId = creatorEntity ? creatorEntity.entityId : null;
                    const homelandEntity = this.geography.find(g => g.name === race.homeland);
                    const homelandEntityId = homelandEntity ? homelandEntity.entityId : null;
                    const entityId = `race-${race.name}`;
                    
                    // Register entity
                    this.registerEntity(entityId, {
                        id: entityId,
                        name: `The ${race.name}`,
                        type: 'mortal_race',
                        entityId,
                        creatorId: creatorEntityId,
                        originId: creatorEntityId,
                        location: homelandEntityId,
                        race: race.name,
                        metadata: { creator: race.creator, homeland: race.homeland },
                        createdAt: race.year,
                    });
                    
                    this.logEvent(
                        race.year,
                        'mortal_race',
                        `The ${race.name} ${method} and settled in ${race.homeland}, establishing the first mortal civilizations.`,
                        'important',
                        { 
                            race: race.name, 
                            creator: race.creator, 
                            homeland: race.homeland,
                            entityId,
                            raceEntityId: entityId,
                            creatorId: creatorEntityId,
                            locationId: homelandEntityId,
                        }
                    );
                });
            }

            generateConceptualBeings() {
                // Must have mortal races first - conceptual beings are born from worship
                if (!this.mortalRaces || this.mortalRaces.length === 0) {
                    console.warn('Cannot generate conceptual beings: no mortal races exist yet');
                    return;
                }
                
                // Large pool of possible concepts
                const allConcepts = [
                    // Major themes
                    'War', 'Battle', 'Blood', 'Death', 'Life', 'Birth',
                    'Love', 'Hate', 'Passion', 'Desire', 'Lust',
                    'Justice', 'Law', 'Order', 'Chaos', 'Freedom',
                    'Wisdom', 'Knowledge', 'Truth', 'Secrets', 'Mystery',
                    'Luck', 'Fortune', 'Fate', 'Destiny', 'Chance',
                    'Courage', 'Fear', 'Hope', 'Despair', 'Joy', 'Sorrow',
                    'Wealth', 'Poverty', 'Trade', 'Commerce', 'Greed',
                    'Fertility', 'Harvest', 'Growth', 'Decay', 'Nature',
                    'Fire', 'Water', 'Earth', 'Air', 'Storm', 'Thunder',
                    'Hunting', 'Beasts', 'Wilderness', 'Forest', 'Mountain',
                    'Craft', 'Art', 'Music', 'Poetry', 'Storytelling',
                    'Healing', 'Disease', 'Plague', 'Medicine',
                    'Magic', 'Sorcery', 'Necromancy', 'Divination',
                    'Honor', 'Dishonor', 'Betrayal', 'Loyalty',
                    'Revenge', 'Mercy', 'Compassion', 'Cruelty',
                    'Forge', 'Stone', 'Metal', 'Mining', 'Smithing',
                ];

                // Race-specific concept preferences (what each race is likely to worship)
                const raceConceptPreferences = {
                    'Humans': ['War', 'Justice', 'Love', 'Wealth', 'Trade', 'Courage', 'Honor', 'Fertility', 'Harvest'],
                    'Dwarves': ['Craft', 'Forge', 'Stone', 'Metal', 'Mining', 'Smithing', 'Wealth', 'Honor', 'Order'],
                    'Elves': ['Nature', 'Forest', 'Wisdom', 'Magic', 'Art', 'Music', 'Beauty', 'Life', 'Growth'],
                    'Orcs': ['War', 'Battle', 'Blood', 'Strength', 'Rage', 'Fury', 'Chaos', 'Hunting', 'Beasts'],
                    'Goblins': ['Trickery', 'Cunning', 'Secrets', 'Stealth', 'Greed', 'Chaos', 'Darkness', 'Mischief'],
                };

                // Generate pantheons for each race
                const rng = this.createRNG(`${this.seed}-pantheons`);
                const allConceptualBeings = [];
                
                this.mortalRaces.forEach(race => {
                    const raceRng = this.createRNG(`${this.seed}-pantheon-${race.name}`);
                    const preferredConcepts = raceConceptPreferences[race.name] || ['Wisdom', 'Strength', 'Courage'];
                    
                    // Each race gets 2-4 gods from their preferred concepts
                    const numGods = Math.floor(raceRng() * 3) + 2; // 2-4 gods per race
                    const raceConcepts = [];
                    
                    // Select from preferred concepts first
                    for (let i = 0; i < numGods && i < preferredConcepts.length; i++) {
                        const concept = preferredConcepts[Math.floor(raceRng() * preferredConcepts.length)];
                        if (!raceConcepts.includes(concept) && allConcepts.includes(concept)) {
                            raceConcepts.push(concept);
                        }
                    }
                    
                    // Fill remaining slots from all concepts if needed
                    while (raceConcepts.length < numGods) {
                        const concept = allConcepts[Math.floor(raceRng() * allConcepts.length)];
                        if (!raceConcepts.includes(concept)) {
                            raceConcepts.push(concept);
                        }
                    }
                    
                    // Generate conceptual beings for this race's pantheon
                    raceConcepts.forEach((concept, index) => {
                        const conceptRng = this.createRNG(`${this.seed}-${race.name}-${concept}`);
                        const name = this.generateConceptualBeingName(concept, conceptRng);
                        const entityId = `conceptual-${race.name}-${concept}`;
                        
                        // Calculate year - starts after the race exists, spaced out over time
                        const yearsAfterRace = 50 + (index * 30); // 50, 80, 110, 140 years after race creation
                        const year = race.year + yearsAfterRace;
                        
                        allConceptualBeings.push({
                            name,
                            concept,
                            race: race.name,
                            year,
                            entityId,
                        });
                    });
                });

                // Sort by year and log events
                allConceptualBeings.sort((a, b) => a.year - b.year);
                
                allConceptualBeings.forEach(being => {
                    const raceEntity = this.mortalRaces.find(r => r.name === being.race);
                    const raceEntityId = raceEntity ? `race-${being.race}` : null;
                    
                    // Register entity
                    this.registerEntity(being.entityId, {
                        id: being.entityId,
                        name: being.name,
                        type: 'conceptual_being',
                        entityId: being.entityId,
                        originId: raceEntityId,
                        race: being.race,
                        metadata: { 
                            conceptualType: being.concept,
                            pantheon: `Pantheon of the ${being.race}`,
                        },
                        createdAt: being.year,
                    });
                    
                    this.logEvent(
                        being.year,
                        'conceptual_being',
                        `${being.name} (${being.concept}) was born from the worship of the ${being.race}. As the ${being.race} began to believe in ${being.concept.toLowerCase()}, their collective faith gave form to this conceptual being, making ${being.name} a god of the ${being.race} pantheon.`,
                        'important',
                        { 
                            conceptualType: being.concept, 
                            name: being.name, 
                            entityId: being.entityId,
                            race: being.race,
                            raceEntityId: raceEntityId,
                            pantheon: `Pantheon of the ${being.race}`,
                        }
                    );
                });
            }
            
            generateConceptualBeingName(concept, rng) {
                const nameTemplates = {
                    prefixes: ['The', 'Lord', 'Lady', 'The Great', 'The Eternal', 'The Divine', 'The Sacred'],
                    getSuffixes: (concept) => {
                        // Generate appropriate suffixes based on concept
                        if (concept.includes('War') || concept.includes('Battle') || concept.includes('Blood')) {
                            return ['War', 'Battle', 'Conflict', 'Struggle', 'Rage', 'Fury'];
                        } else if (concept.includes('Love') || concept.includes('Passion') || concept.includes('Desire')) {
                            return ['Love', 'Desire', 'Passion', 'Devotion', 'Heart'];
                        } else if (concept.includes('Death') || concept.includes('Reaper')) {
                            return ['Death', 'Reaper', 'End', 'Passing', 'Grave'];
                        } else if (concept.includes('Wisdom') || concept.includes('Knowledge')) {
                            return ['Wisdom', 'Knowledge', 'Truth', 'Understanding', 'Learning'];
                        } else if (concept.includes('Craft') || concept.includes('Forge') || concept.includes('Smithing')) {
                            return ['Forge', 'Craft', 'Smithing', 'Metal', 'Anvil'];
                        } else if (concept.includes('Nature') || concept.includes('Forest') || concept.includes('Growth')) {
                            return ['Nature', 'Forest', 'Growth', 'Life', 'Wild'];
                        } else {
                            return [concept, concept + 's', 'The ' + concept];
                        }
                    },
                };
                
                const prefix = nameTemplates.prefixes[Math.floor(rng() * nameTemplates.prefixes.length)];
                const suffixes = nameTemplates.getSuffixes(concept);
                const suffix = suffixes[Math.floor(rng() * suffixes.length)];
                return `${prefix} ${suffix}`;
            }

            generateOrganizations() {
                // Organizations form over time as civilizations develop
                const orgEvents = [
                    { name: 'The First Kingdom', type: 'kingdom', race: 'Humans', location: 'The Northern Wastes', year: -2500 },
                    { name: 'The Dwarven Holds', type: 'kingdom', race: 'Dwarves', location: 'The Dragon\'s Spine Mountains', year: -2400 },
                    { name: 'The Elven Realms', type: 'realm', race: 'Elves', location: 'The Whispering Forest', year: -2300 },
                    { name: 'The Orc Hordes', type: 'horde', race: 'Orcs', location: 'The Barren Desert', year: -2200 },
                ];

                orgEvents.forEach((org, index) => {
                    const orgRng = this.createRNG(`${this.seed}-org-${index}`);
                    
                    // Generate founder/leader for the organization
                    const leader = this.generateStandoutMortal(org, org.year, orgRng);
                    
                    // Find related entities
                    const raceEntityId = `race-${org.race}`;
                    const locationEntity = this.geography.find(g => g.name === org.location);
                    const locationEntityId = locationEntity ? locationEntity.entityId : null;
                    const orgEntityId = `org-${org.name.replace(/\s+/g, '-').toLowerCase()}`;
                    
                    // Register organization entity
                    this.registerEntity(orgEntityId, {
                        id: orgEntityId,
                        name: org.name,
                        type: 'organization',
                        entityId: orgEntityId,
                        creatorId: leader.entityId,
                        originId: leader.entityId,
                        location: locationEntityId,
                        race: org.race,
                        metadata: { 
                            organizationType: org.type,
                            founder: leader.name,
                        },
                        createdAt: org.year,
                    });
                    
                    // Register leader as standout mortal
                    this.registerEntity(leader.entityId, {
                        id: leader.entityId,
                        name: leader.name,
                        type: 'standout_mortal',
                        entityId: leader.entityId,
                        race: org.race,
                        location: locationEntityId,
                        metadata: {
                            title: leader.title,
                            organizationId: orgEntityId,
                        },
                        createdAt: org.year - 30, // Born ~30 years before founding
                    });
                    
                    this.logEvent(
                        org.year,
                        'organization',
                        `${org.name}, a ${org.type} of the ${org.race}, was established in ${org.location} by ${leader.name}.`,
                        'important',
                        { 
                            organizationType: org.type, 
                            race: org.race, 
                            location: org.location, 
                            name: org.name,
                            entityId: orgEntityId,
                            organizationId: orgEntityId,
                            founderId: leader.entityId,
                            creatorId: leader.entityId,
                            locationId: locationEntityId,
                            raceEntityId: raceEntityId,
                        }
                    );
                    
                    // Log the founder's birth and rise to power
                    this.logEvent(
                        org.year - 30, // Born ~30 years before founding
                        'standout_mortal',
                        `${leader.name} was born to the ${org.race}.`,
                        'normal',
                        { 
                            mortalName: leader.name,
                            race: org.race,
                            entityId: leader.entityId,
                            organizationId: orgEntityId,
                            raceEntityId: raceEntityId,
                        }
                    );
                    
                    this.logEvent(
                        org.year,
                        'standout_mortal',
                        `${leader.name} founded ${org.name} and became its first ${leader.title}.`,
                        'important',
                        { 
                            mortalName: leader.name,
                            title: leader.title,
                            organizationId: orgEntityId,
                            entityId: leader.entityId,
                        }
                    );
                    
                    this.organizations.push({ ...org, founder: leader, entityId: orgEntityId });
                });
            }

            generateStandoutMortal(org, orgYear, rng) {
                const firstNames = {
                    'Humans': ['Aethelred', 'Isolde', 'Valerius', 'Elena', 'Marcus', 'Sophia', 'Theodore', 'Victoria'],
                    'Dwarves': ['Thorgrim', 'Borin', 'Durin', 'Helga', 'Grimbold', 'Frida', 'Thorin', 'Dagna'],
                    'Elves': ['Aeliana', 'Thalius', 'Lyralei', 'Elandris', 'Sylvan', 'Arielle', 'Eldrin', 'Nimue'],
                    'Orcs': ['Grubnak', 'Bloodaxe', 'Skullcrusher', 'Grimjaw', 'Ironfist', 'Bonebreaker'],
                    'Goblins': ['Snikkit', 'Gribble', 'Nix', 'Zog', 'Grik'],
                };
                
                const titles = {
                    'kingdom': ['King', 'Queen', 'Lord', 'Lady'],
                    'horde': ['War-Chief', 'Chieftain', 'Warlord'],
                    'realm': ['High Lord', 'Lady', 'Archon'],
                    'tower': ['Necromancer', 'Archmage', 'Lich Lord'],
                };
                
                const nameList = firstNames[org.race] || ['Unknown'];
                const titleList = titles[org.type] || ['Leader'];
                
                const firstName = nameList[Math.floor(rng() * nameList.length)];
                const title = titleList[Math.floor(rng() * titleList.length)];
                
                // Add epithet
                const epithets = ['the Bold', 'the Wise', 'the Great', 'the Conqueror', 'the Builder', 'the First', 'the Mighty'];
                const epithet = epithets[Math.floor(rng() * epithets.length)];
                const name = `${title} ${firstName} ${epithet}`;
                
                return {
                    name,
                    title,
                    race: org.race,
                    entityId: `mortal-${firstName}-${orgYear}`,
                    birthYear: orgYear - 30,
                    organizationId: `org-${org.name}`,
                };
            }

            // Calculate the actual year something was created based on its age
            getCreationYear(age) {
                return this.currentYear - age;
            }

            generateFeatureCreationEvent(feature, cellX, cellY, age) {
                const creationYear = age ? this.getCreationYear(age) : this.currentYear - 100;
                const importance = feature.type === 'organization' ? 'important' : 'normal';
                const summary = `${feature.name} was ${feature.type === 'geography' ? 'formed' : 'founded'} at location (${cellX}, ${cellY}).`;
                return this.logEvent(creationYear, 'world_creation', summary, importance, {
                    featureType: feature.type,
                    featureName: feature.name,
                    location: { x: cellX, y: cellY },
                    age,
                });
            }

            generateDungeonCreationEvent(dungeonName, cellX, cellY, builder, age) {
                const creationYear = this.getCreationYear(age);
                const summary = `${dungeonName} was built by ${builder} at location (${cellX}, ${cellY}).`;
                return this.logEvent(creationYear, 'dungeon_creation', summary, 'important', {
                    dungeonName,
                    builder,
                    age,
                    location: { x: cellX, y: cellY },
                });
            }

            generateBossEvent(bossName, bossType, level, dungeonName, dungeonAge) {
                // Boss takes control some time after dungeon is built
                const dungeonCreationYear = this.getCreationYear(dungeonAge);
                const bossYear = dungeonCreationYear + Math.floor(this.rng() * 100) + 50; // 50-150 years after dungeon creation
                const summary = `${bossName}, a ${bossType.toLowerCase()}, took control of level ${Math.abs(level)} in ${dungeonName}.`;
                return this.logEvent(bossYear, 'boss_encounter', summary, 'critical', {
                    bossName,
                    bossType,
                    level,
                    dungeonName,
                });
            }

            generateOrganizationEvent(orgName, leaderName, eventType, age, orgEntityId, leaderEntityId) {
                const eventYear = age ? this.getCreationYear(age) : this.currentYear - 100;
                const summary = `${leaderName} ${eventType} ${orgName}.`;
                return this.logEvent(eventYear, 'organization', summary, 'important', {
                    organizationName: orgName,
                    name: orgName,
                    mortalName: leaderName,
                    leaderName,
                    eventType,
                    entityId: orgEntityId,
                    organizationId: orgEntityId,
                    founderId: leaderEntityId,
                });
            }

            generateHistoricalEvent(eventDesc, timeAgo, location) {
                // Convert "timeAgo" to actual year
                let yearsAgo = 0;
                if (timeAgo.includes('centuries')) {
                    yearsAgo = Math.floor(this.rng() * 500) + 200; // 200-700 years
                } else if (timeAgo.includes('decades')) {
                    yearsAgo = Math.floor(this.rng() * 50) + 20; // 20-70 years
                } else if (timeAgo.includes('years')) {
                    yearsAgo = Math.floor(this.rng() * 20) + 5; // 5-25 years
                }
                const eventYear = this.currentYear - yearsAgo;
                const summary = `${eventDesc} at location (${location.x}, ${location.y}).`;
                return this.logEvent(eventYear, 'historical', summary, 'normal', {
                    description: eventDesc,
                    timeAgo,
                    location,
                });
            }

            getEventsByImportance(importance) {
                return this.getAllEvents('verbose').filter(e => e.importance === importance);
            }
        }

        class MapGenerator {
            constructor() {
                this.surfaceGenerator = new SurfaceGenerator();
                this.richContentGenerator = new RichContentGenerator();
                this.cells = new Map();
                this.richContent = new Map();
            }

            getCellSeed(worldSeed, x, y) {
                return `${worldSeed}-${x}-${y}`;
            }

            shouldHaveDungeon(seed, x, y) {
                const rng = new SeededRNG(`${seed}-dungeon-check`);
                return rng.random() < 0.05; // 5% chance (reduced from 10%)
            }

            generateCell(x, y, worldSeed, density, includeDungeons) {
                const cellSeed = this.getCellSeed(worldSeed, x, y);
                const context = { seed: cellSeed, x, y };
                
                const cell = this.surfaceGenerator.generateCell(context, density);
                
                // Generate rich content for features
                const featureContent = [];
                cell.features.forEach(feature => {
                    const rich = this.richContentGenerator.generateFeatureContent(feature, cellSeed);
                    featureContent.push(rich);
                    
                    // Log feature creation to world history
                    if (window.worldHistoryGenerator) {
                        // Log all feature types including ruins and landmarks
                        if (feature.type === 'ruin' || feature.type === 'landmark' || feature.type === 'trading_post') {
                            window.worldHistoryGenerator.generateFeatureCreationEvent(
                                feature, 
                                x, 
                                y, 
                                rich.provenance.age
                            );
                        } else {
                            window.worldHistoryGenerator.generateFeatureCreationEvent(
                                feature, 
                                x, 
                                y, 
                                rich.provenance.age
                            );
                        }
                        
                        // Log historical events if present
                        if (rich.events) {
                            rich.events.forEach(event => {
                                window.worldHistoryGenerator.generateHistoricalEvent(
                                    event.description,
                                    event.timeAgo,
                                    { x, y }
                                );
                            });
                        }
                        
                        // Log organization leaders
                        if (feature.type === 'organization' && rich.inhabitants) {
                            const leader = rich.inhabitants.find(inh => inh.type === 'leader');
                            if (leader) {
                                const orgName = feature.metadata?.organizationName || feature.name;
                                const orgEntityId = feature.metadata?.organizationEntityId || `org-${orgName}`;
                                const leaderEntityId = leader.entityId || `mortal-${leader.name}`;
                                
                                // Log leader birth
                                const birthYear = window.worldHistoryGenerator.getCreationYear(rich.provenance.age) - 30;
                                window.worldHistoryGenerator.logEvent(
                                    birthYear,
                                    'standout_mortal',
                                    `${leader.name} was born.`,
                                    'normal',
                                    {
                                        mortalName: leader.name,
                                        entityId: leaderEntityId,
                                        organizationId: orgEntityId,
                                    }
                                );
                                
                                // Log organization founding
                                window.worldHistoryGenerator.generateOrganizationEvent(
                                    orgName,
                                    leader.name,
                                    'founded',
                                    rich.provenance.age,
                                    orgEntityId,
                                    leaderEntityId
                                );
                                
                                // Log leader's rise to power
                                const foundingYear = window.worldHistoryGenerator.getCreationYear(rich.provenance.age);
                                window.worldHistoryGenerator.logEvent(
                                    foundingYear,
                                    'standout_mortal',
                                    `${leader.name} became the ruler of ${orgName}.`,
                                    'important',
                                    {
                                        mortalName: leader.name,
                                        entityId: leaderEntityId,
                                        organizationId: orgEntityId,
                                    }
                                );
                            }
                        }
                    }
                });
                this.richContent.set(`${x},${y}-features`, featureContent);

                if (includeDungeons && this.shouldHaveDungeon(cellSeed, x, y)) {
                    const dungeonSeed = `${cellSeed}-dungeon`;
                    const dungeonContent = this.richContentGenerator.generateDungeonContent(dungeonSeed, x, y);
                    this.richContent.set(`${x},${y}-dungeon`, dungeonContent);
                    
                    // Log dungeon creation
                    if (window.worldHistoryGenerator) {
                        window.worldHistoryGenerator.generateDungeonCreationEvent(
                            dungeonContent.dungeon.name,
                            x,
                            y,
                            dungeonContent.provenance.builder,
                            dungeonContent.provenance.age
                        );
                        
                        // Log main boss
                        if (dungeonContent.mainBoss) {
                            window.worldHistoryGenerator.generateBossEvent(
                                dungeonContent.mainBoss.name,
                                dungeonContent.mainBoss.type,
                                dungeonContent.mainBoss.level,
                                dungeonContent.dungeon.name,
                                dungeonContent.provenance.age
                            );
                        }
                        
                        // Log mid-bosses
                        if (dungeonContent.midBosses) {
                            dungeonContent.midBosses.forEach(boss => {
                                window.worldHistoryGenerator.generateBossEvent(
                                    boss.name,
                                    boss.type,
                                    boss.level,
                                    dungeonContent.dungeon.name,
                                    dungeonContent.provenance.age
                                );
                            });
                        }
                    }
                    
                    cell.dungeonEntrances.push({
                        id: `entrance-${x}-${y}`,
                        name: dungeonContent.dungeon.name,
                        description: `An entrance to ${dungeonContent.dungeon.name}`,
                        surfaceX: x,
                        surfaceY: y,
                        dungeonId: `dungeon-${x}-${y}`,
                    });
                }

                return cell;
            }
        }

        // UI State
        let mapGenerator = new MapGenerator();
        let currentCells = new Map();
        let selectedCell = null;

        // UI Elements
        const mapGrid = document.getElementById('mapGrid');
        const cellDetails = document.getElementById('cellDetails');
        const generateBtn = document.getElementById('generateBtn');
        const randomSeedBtn = document.getElementById('randomSeedBtn');

        // Update slider values
        document.getElementById('gridSize').addEventListener('input', (e) => {
            document.getElementById('gridSizeValue').textContent = e.target.value;
        });
        document.getElementById('centerX').addEventListener('input', (e) => {
            document.getElementById('centerXValue').textContent = e.target.value;
        });
        document.getElementById('centerY').addEventListener('input', (e) => {
            document.getElementById('centerYValue').textContent = e.target.value;
        });

        // Generate map
        function generateMap() {
            const seed = document.getElementById('seed').value;
            const gridSize = parseInt(document.getElementById('gridSize').value);
            const centerX = parseInt(document.getElementById('centerX').value);
            const centerY = parseInt(document.getElementById('centerY').value);
            const density = document.getElementById('density').value;
            const includeDungeons = document.getElementById('includeDungeons').checked;

            // Fix grid size: gridSize should be exactly that many cells
            // For gridSize=10, we want 10 cells, so from -4 to +5 (10 cells total)
            const halfSize = Math.floor((gridSize - 1) / 2);
            const xMin = centerX - halfSize;
            const xMax = centerX + (gridSize - halfSize - 1);
            const yMin = centerY - halfSize;
            const yMax = centerY + (gridSize - halfSize - 1);

            currentCells.clear();
            mapGrid.innerHTML = '';
            mapGrid.style.gridTemplateColumns = `repeat(${gridSize}, 1fr)`;

            for (let y = yMax; y >= yMin; y--) {
                for (let x = xMin; x <= xMax; x++) {
                    const cell = mapGenerator.generateCell(x, y, seed, density, includeDungeons);
                    currentCells.set(`${x},${y}`, cell);

                    const cellEl = document.createElement('div');
                    cellEl.className = 'map-cell';
                    cellEl.dataset.x = x;
                    cellEl.dataset.y = y;

                    // Determine cell class based on features
                    if (cell.dungeonEntrances.length > 0) {
                        cellEl.classList.add('has-dungeon');
                        cellEl.textContent = 'D';
                    } else if (cell.features.some(f => f.type === 'geography')) {
                        cellEl.classList.add('has-geography');
                        cellEl.textContent = 'G';
                    } else if (cell.features.some(f => f.type === 'organization')) {
                        cellEl.classList.add('has-organization');
                        cellEl.textContent = 'O';
                    } else if (cell.features.some(f => f.type === 'landmark')) {
                        cellEl.classList.add('has-landmark');
                        cellEl.textContent = 'L';
                    } else if (cell.features.some(f => f.type === 'ruin')) {
                        cellEl.classList.add('has-ruin');
                        cellEl.textContent = 'R';
                    } else if (cell.features.some(f => f.type === 'trading_post')) {
                        cellEl.classList.add('has-trading');
                        cellEl.textContent = 'T';
                    } else {
                        cellEl.classList.add('empty');
                    }

                    cellEl.addEventListener('click', () => selectCell(x, y));
                    mapGrid.appendChild(cellEl);
                }
            }

            selectedCell = null;
            updateCellDetails();
            updateWorldHistory();
            
            // Setup entity search and filter
            setupEntityFilters();
        }
        
        // Setup entity search and filter
        function setupEntityFilters() {
            const searchInput = document.getElementById('entitySearch');
            const typeFilter = document.getElementById('entityTypeFilter');
            
            if (searchInput) {
                searchInput.addEventListener('input', () => {
                    filterAndSearchHistory();
                });
            }
            
            if (typeFilter) {
                typeFilter.addEventListener('change', () => {
                    filterAndSearchHistory();
                });
            }
        }
        
        // Filter and search history
        function filterAndSearchHistory() {
            if (!window.worldHistoryGenerator) return;
            
            const searchQuery = document.getElementById('entitySearch')?.value.toLowerCase() || '';
            const typeFilter = document.getElementById('entityTypeFilter')?.value || '';
            
            let events = window.worldHistoryGenerator.getAllEvents('important');
            
            // Filter by type if specified
            if (typeFilter) {
                events = events.filter(event => {
                    const metadata = event.metadata || {};
                    const entityId = metadata.entityId || metadata.organizationId || metadata.founderId;
                    if (!entityId) return false;
                    const entity = window.worldHistoryGenerator.getEntity(entityId);
                    return entity && entity.type === typeFilter;
                });
            }
            
            // Filter by search query
            if (searchQuery) {
                events = events.filter(event => {
                    // Search in summary
                    if (event.summary.toLowerCase().includes(searchQuery)) return true;
                    
                    // Search in entity names
                    const metadata = event.metadata || {};
                    const entityIds = [
                        metadata.entityId,
                        metadata.organizationId,
                        metadata.founderId,
                        metadata.creatorId,
                    ].filter(id => id);
                    
                    return entityIds.some(entityId => {
                        const entity = window.worldHistoryGenerator.getEntity(entityId);
                        return entity && entity.name.toLowerCase().includes(searchQuery);
                    });
                });
            }
            
            // Update display with filtered events
            const historyContainer = document.getElementById('historyEntries');
            if (events.length === 0) {
                historyContainer.innerHTML = '<p style="text-align: center; color: #666; font-style: italic;">No events match your filters</p>';
                return;
            }
            
            let html = '';
            events.forEach(event => {
                let yearStr = '';
                if (event.year < 0) {
                    yearStr = `${Math.abs(event.year)} Before Era`;
                } else if (event.year === 0) {
                    yearStr = 'Year 0 (Present Era)';
                } else {
                    yearStr = `Year ${event.year}`;
                }
                
                const metadata = event.metadata || {};
                let summary = makeEntityNamesClickable(event.summary, metadata);
                
                html += `
                    <div class="history-entry ${event.importance}">
                        <div class="history-timestamp">${yearStr}</div>
                        <div class="history-summary">${summary}</div>
                        <div class="history-meta">Type: ${event.type} | Importance: ${event.importance}</div>
                    </div>
                `;
            });
            
            historyContainer.innerHTML = html;
            
            // Add click handlers
            document.querySelectorAll('.entity-link').forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    const entityId = link.getAttribute('data-entity-id');
                    const entityName = link.getAttribute('data-entity-name');
                    showEntityHistory(entityId, entityName);
                });
            });
        }

        // Select cell
        function selectCell(x, y) {
            // Remove previous selection
            document.querySelectorAll('.map-cell.selected').forEach(el => {
                el.classList.remove('selected');
            });

            // Add selection to clicked cell
            const cellEl = document.querySelector(`.map-cell[data-x="${x}"][data-y="${y}"]`);
            if (cellEl) {
                cellEl.classList.add('selected');
            }

            selectedCell = currentCells.get(`${x},${y}`);
            updateCellDetails();
        }

        // Update cell details
        function updateCellDetails() {
            if (!selectedCell) {
                cellDetails.innerHTML = '<div class="no-selection">Select a cell to view details</div>';
                return;
            }

            const cell = selectedCell;
            const key = `${cell.x},${cell.y}`;
            let html = `
                <div class="cell-info">
                    <h3>Cell (${cell.x}, ${cell.y})</h3>
                    <p><span class="label">Seed:</span> ${cell.seed}</p>
                    <p><span class="label">Features:</span> ${cell.features.length}</p>
                    <p><span class="label">Dungeons:</span> ${cell.dungeonEntrances.length}</p>
                </div>
            `;

            if (cell.features.length === 0 && cell.dungeonEntrances.length === 0) {
                html += '<div class="cell-info"><p><em>This cell is empty - nothingness. A vast expanse of featureless terrain stretching to the horizon.</em></p></div>';
            } else {
                // Display rich feature content
                const featureContent = mapGenerator.richContent.get(`${key}-features`) || [];
                featureContent.forEach(rich => {
                    // Use organization name if available
                    const displayName = rich.feature.metadata?.organizationName || rich.feature.name;
                    html += `
                        <div class="feature-item">
                            <h4>${displayName}</h4>
                            <p><strong>History:</strong> ${rich.history}</p>
                            ${rich.provenance.age ? `<p><strong>Age:</strong> ${rich.provenance.age} years old</p>` : ''}
                            ${rich.provenance.creator ? `<p><strong>Created by:</strong> ${rich.provenance.creator}</p>` : ''}
                            <p><strong>Significance:</strong> ${rich.lore.significance}</p>
                            ${rich.inhabitants ? `
                                <p><strong>Inhabitants:</strong></p>
                                ${rich.inhabitants.map(inh => {
                                    if (inh.type === 'leader') {
                                        const leaderLink = `<a href="#" class="entity-link" data-entity-id="${inh.entityId || `mortal-${inh.name}`}" data-entity-name="${inh.name}">${inh.name}</a>`;
                                        return `<p style="margin-left: 15px; margin-top: 5px;">
                                            <strong>${leaderLink}</strong> - ${inh.description}
                                        </p>`;
                                    } else {
                                        return `<p style="margin-left: 15px; margin-top: 5px;">
                                            ${inh.leader ? `<strong>${inh.name}</strong> - Led by ${inh.leader}. ${inh.description}` : `${inh.name || inh.type}: ${inh.description}`}
                                        </p>`;
                                    }
                                }).join('')}
                            ` : ''}
                            ${rich.events ? `
                                <p><strong>Historical Events:</strong></p>
                                ${rich.events.map(ev => `
                                    <p style="margin-left: 15px; margin-top: 5px;">
                                        <em>${ev.description}</em> (${ev.timeAgo} ago)
                                    </p>
                                `).join('')}
                            ` : ''}
                            <span class="feature-type">${rich.feature.type}</span>
                        </div>
                    `;
                });

                // Display dungeon content
                cell.dungeonEntrances.forEach(entrance => {
                    const dungeonContent = mapGenerator.richContent.get(`${key}-dungeon`);
                    if (dungeonContent) {
                        html += `
                            <div class="feature-item">
                                <h4>${dungeonContent.dungeon.name}</h4>
                                <p><strong>History:</strong> ${dungeonContent.history}</p>
                                <p><strong>Built by:</strong> ${dungeonContent.provenance.builder} ${dungeonContent.provenance.age} years ago</p>
                                <p><strong>Purpose:</strong> ${dungeonContent.provenance.purpose}</p>
                                <p><strong>Depth:</strong> ${dungeonContent.dungeon.maxDepth} levels deep</p>
                                <p><strong>Story:</strong> ${dungeonContent.lore.story}</p>
                                ${dungeonContent.mainBoss ? `
                                    <p style="margin-top: 10px;"><strong>Main Boss (Level ${Math.abs(dungeonContent.mainBoss.level)}):</strong></p>
                                    <p style="margin-left: 15px;">
                                        <strong>${dungeonContent.mainBoss.name}</strong> - ${dungeonContent.mainBoss.type}<br>
                                        ${dungeonContent.mainBoss.description}<br>
                                        <em>History:</em> ${dungeonContent.mainBoss.history}<br>
                                        <em>Powers:</em> ${dungeonContent.mainBoss.powers.join(', ')}
                                    </p>
                                ` : ''}
                                ${dungeonContent.midBosses && dungeonContent.midBosses.length > 0 ? `
                                    <p style="margin-top: 10px;"><strong>Mid-Bosses:</strong></p>
                                    ${dungeonContent.midBosses.map(boss => `
                                        <p style="margin-left: 15px;">
                                            <strong>${boss.name}</strong> - ${boss.type} at Level ${Math.abs(boss.level)}<br>
                                            ${boss.description}
                                        </p>
                                    `).join('')}
                                ` : ''}
                                <span class="feature-type">dungeon_entrance</span>
                            </div>
                        `;
                    } else {
                        html += `
                            <div class="feature-item">
                                <h4>${entrance.name}</h4>
                                <p>${entrance.description}</p>
                                <span class="feature-type">dungeon_entrance</span>
                            </div>
                        `;
                    }
                });
            }

            cellDetails.innerHTML = html;
            
            // Add click handlers for entity links in cell details
            cellDetails.querySelectorAll('.entity-link').forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    const entityId = link.getAttribute('data-entity-id');
                    const entityName = link.getAttribute('data-entity-name');
                    showEntityHistory(entityId, entityName);
                });
            });
        }

        // Extract all entity names from text and make them clickable
        function makeEntityNamesClickable(text, metadata = {}) {
            if (!window.worldHistoryGenerator) return text;
            
            let result = text;
            const allEntities = window.worldHistoryGenerator.entityRegistry.getAllEntities();
            
            // First, replace entities mentioned in metadata
            const entityIds = [
                metadata.entityId,
                metadata.organizationId,
                metadata.founderId,
                metadata.creatorId,
                metadata.originId,
                metadata.locationId,
                metadata.raceEntityId,
            ].filter(id => id);
            
            entityIds.forEach(entityId => {
                const entity = window.worldHistoryGenerator.getEntity(entityId);
                if (entity) {
                    const nameRegex = new RegExp(`\\b${entity.name.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'gi');
                    result = result.replace(nameRegex, (match) => {
                        return `<a href="#" class="entity-link" data-entity-id="${entity.entityId}" data-entity-name="${entity.name}">${match}</a>`;
                    });
                }
            });
            
            // Then, try to match other entity names in the text
            allEntities.forEach(entity => {
                // Skip if already linked
                if (result.includes(`data-entity-id="${entity.entityId}"`)) return;
                
                const nameRegex = new RegExp(`\\b${entity.name.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'gi');
                // Only replace if not already inside a link
                result = result.replace(nameRegex, (match, offset) => {
                    // Check if we're inside an existing link
                    const before = result.substring(0, offset);
                    const after = result.substring(offset);
                    if (before.includes('<a') && !before.split('<a').pop().includes('>')) {
                        return match; // Inside a link, don't replace
                    }
                    return `<a href="#" class="entity-link" data-entity-id="${entity.entityId}" data-entity-name="${entity.name}">${match}</a>`;
                });
            });
            
            return result;
        }

        // Update world history display (only shows critical/important events in main view)
        function updateWorldHistory() {
            const historyContainer = document.getElementById('historyEntries');
            if (!window.worldHistoryGenerator) {
                historyContainer.innerHTML = '<p style="text-align: center; color: #666; font-style: italic;">No history available</p>';
                return;
            }

            // Only show critical and important events in main world history
            const events = window.worldHistoryGenerator.getAllEvents('important');
            
            if (events.length === 0) {
                historyContainer.innerHTML = '<p style="text-align: center; color: #666; font-style: italic;">No events recorded yet</p>';
                return;
            }

            let html = '';
            events.forEach(event => {
                // Format year display
                let yearStr = '';
                if (event.year < 0) {
                    yearStr = `${Math.abs(event.year)} Before Era`;
                } else if (event.year === 0) {
                    yearStr = 'Year 0 (Present Era)';
                } else {
                    yearStr = `Year ${event.year}`;
                }
                
                // Make entity names clickable
                const metadata = event.metadata || {};
                let summary = makeEntityNamesClickable(event.summary, metadata);
                
                html += `
                    <div class="history-entry ${event.importance}">
                        <div class="history-timestamp">${yearStr}</div>
                        <div class="history-summary">${summary}</div>
                        <div class="history-meta">Type: ${event.type} | Importance: ${event.importance}</div>
                    </div>
                `;
            });

            historyContainer.innerHTML = html;
            
            // Add click handlers for entity links
            document.querySelectorAll('.entity-link').forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    const entityId = link.getAttribute('data-entity-id');
                    const entityName = link.getAttribute('data-entity-name');
                    showEntityHistory(entityId, entityName);
                });
            });
        }
        
        // Show nested history for a specific entity
        function showEntityHistory(entityId, entityName) {
            if (!window.worldHistoryGenerator) return;
            
            const entity = window.worldHistoryGenerator.getEntity(entityId);
            if (!entity) {
                alert(`No history found for ${entityName}`);
                return;
            }
            
            // Get all events for this entity (including normal/verbose)
            const events = window.worldHistoryGenerator.getEntityHistory(entityId, 'verbose');
            
            // Get provenance chain
            const provenanceChain = window.worldHistoryGenerator.getProvenanceChain(entityId);
            
            // Get related entities
            const relatedEntities = window.worldHistoryGenerator.getRelatedEntities(entityId);
            
            // Get created entities
            const createdEntities = window.worldHistoryGenerator.getCreatedEntities(entityId);
            
            // Entity type badge
            const typeLabels = {
                'primordial': 'Primordial Being',
                'cosmic_creator': 'Cosmic Creator',
                'geography': 'Geography',
                'conceptual_being': 'God',
                'demigod': 'Demi-God',
                'mortal_race': 'Mortal Race',
                'organization': 'Organization',
                'standout_mortal': 'Standout Mortal',
                'legendary_item': 'Legendary Item',
            };
            const typeLabel = typeLabels[entity.type] || entity.type;
            
            // Format age
            const age = entity.createdAt ? Math.abs(entity.createdAt) : null;
            const ageStr = age ? `${age} years old` : 'Age unknown';
            
            // Create modal for nested history
            const modal = document.createElement('div');
            modal.className = 'entity-history-modal';
            modal.innerHTML = `
                <div class="entity-history-content">
                    <div class="entity-history-header">
                        <div>
                            <h2>${entityName}</h2>
                            <span class="entity-type-badge" style="display: inline-block; padding: 4px 8px; background: #0f3460; border-radius: 4px; font-size: 0.8em; margin-left: 10px;">${typeLabel}</span>
                        </div>
                        <button class="close-modal" onclick="this.closest('.entity-history-modal').remove()"></button>
                    </div>
                    <div class="entity-history-body">
                        ${provenanceChain.chain.length > 1 ? `
                            <div class="provenance-chain" style="background: #0f3460; padding: 15px; border-radius: 4px; margin-bottom: 20px;">
                                <h3 style="color: #ffd700; margin-bottom: 10px;">Provenance Chain</h3>
                                <div style="font-size: 0.9em; line-height: 1.8;">
                                    ${provenanceChain.chain.map((link, idx) => {
                                        const isLast = idx === provenanceChain.chain.length - 1;
                                        const connector = isLast ? '' : '  ';
                                        return `<a href="#" class="entity-link" data-entity-id="${link.entityId}" data-entity-name="${link.name}" style="color: #4da6ff;">${link.name}</a>${connector}`;
                                    }).join('')}
                                </div>
                            </div>
                        ` : ''}
                        
                        ${createdEntities.length > 0 ? `
                            <div class="created-entities" style="background: #0f3460; padding: 15px; border-radius: 4px; margin-bottom: 20px;">
                                <h3 style="color: #ffd700; margin-bottom: 10px;">Created</h3>
                                <ul style="list-style: none; padding: 0;">
                                    ${createdEntities.map(e => `
                                        <li style="margin: 5px 0;">
                                            <a href="#" class="entity-link" data-entity-id="${e.entityId}" data-entity-name="${e.name}" style="color: #4da6ff;">${e.name}</a>
                                        </li>
                                    `).join('')}
                                </ul>
                            </div>
                        ` : ''}
                        
                        ${relatedEntities.length > 0 ? `
                            <div class="related-entities" style="background: #0f3460; padding: 15px; border-radius: 4px; margin-bottom: 20px;">
                                <h3 style="color: #ffd700; margin-bottom: 10px;">Related Entities</h3>
                                <ul style="list-style: none; padding: 0;">
                                    ${relatedEntities.slice(0, 10).map(e => `
                                        <li style="margin: 5px 0;">
                                            <a href="#" class="entity-link" data-entity-id="${e.entityId}" data-entity-name="${e.name}" style="color: #4da6ff;">${e.name}</a>
                                            <span style="color: #888; font-size: 0.8em; margin-left: 8px;">(${typeLabels[e.type] || e.type})</span>
                                        </li>
                                    `).join('')}
                                </ul>
                            </div>
                        ` : ''}
                        
                        <div style="margin-bottom: 15px; color: #aaa; font-size: 0.9em;">
                            <strong>Age:</strong> ${ageStr}
                        </div>
                        
                        <h3 style="color: #ffd700; margin-bottom: 15px;">History</h3>
                        ${events.length === 0 ? 
                            '<p style="text-align: center; color: #666; font-style: italic;">No detailed history available</p>' :
                            events.map(event => {
                                let yearStr = '';
                                if (event.year < 0) {
                                    yearStr = `${Math.abs(event.year)} Before Era`;
                                } else if (event.year === 0) {
                                    yearStr = 'Year 0 (Present Era)';
                                } else {
                                    yearStr = `Year ${event.year}`;
                                }
                                
                                // Extract entity names and make them clickable
                                let summary = event.summary;
                                const metadata = event.metadata || {};
                                
                                // Make entity names clickable
                                if (metadata.entityId) {
                                    const e = window.worldHistoryGenerator.getEntity(metadata.entityId);
                                    if (e) {
                                        summary = summary.replace(new RegExp(e.name, 'g'), 
                                            `<a href="#" class="entity-link" data-entity-id="${e.entityId}" data-entity-name="${e.name}">${e.name}</a>`);
                                    }
                                }
                                
                                return `
                                    <div class="history-entry ${event.importance}">
                                        <div class="history-timestamp">${yearStr}</div>
                                        <div class="history-summary">${summary}</div>
                                        <div class="history-meta">Type: ${event.type} | Importance: ${event.importance}</div>
                                    </div>
                                `;
                            }).join('')
                        }
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Add click handlers for entity links in modal
            modal.querySelectorAll('.entity-link').forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    const targetEntityId = link.getAttribute('data-entity-id');
                    const targetEntityName = link.getAttribute('data-entity-name');
                    // Close current modal and open new one
                    modal.remove();
                    showEntityHistory(targetEntityId, targetEntityName);
                });
            });
        }

        // Random seed
        function randomSeed() {
            const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
            let seed = '';
            for (let i = 0; i < 12; i++) {
                seed += chars[Math.floor(Math.random() * chars.length)];
            }
            document.getElementById('seed').value = seed;
        }

        // Initialize world history generator with seed
        function initializeHistoryGenerator() {
            const seed = document.getElementById('seed').value;
            window.worldHistoryGenerator = new WorldHistoryGenerator(seed);
        }
        
        initializeHistoryGenerator();

        // Event listeners
        generateBtn.addEventListener('click', () => {
            // Reset history for new map with current seed
            initializeHistoryGenerator();
            generateMap();
        });
        randomSeedBtn.addEventListener('click', randomSeed);

        // Generate initial map
        generateMap();
    </script>
</body>
</html>

